<?xml version="1.0" encoding="UTF-8"?>
<!-- RC racetrack SVG: 600mm x 2000mm, 250mm road width, moderate meander, red/white kerbs, solid start, chequered finish -->
<svg xmlns="http://www.w3.org/2000/svg" width="600mm" height="2000mm" viewBox="0 0 600 2000" version="1.1">
  <defs>
    <!-- Chequered pattern for finish line -->
    <pattern id="checker" width="20" height="20" patternUnits="userSpaceOnUse">
      <!-- White background so non-black areas render white -->
      <rect width="20" height="20" x="0" y="0" fill="#ffffff" />
      <!-- Black squares -->
      <rect width="10" height="10" x="0" y="0" fill="#000000" />
      <rect width="10" height="10" x="10" y="10" fill="#000000" />
    </pattern>
    <style>
      .track-outline { stroke: #ffffff; stroke-width: 254; stroke-linecap: butt; stroke-linejoin: round; fill: none; }
      .track-surface { stroke: #333333; stroke-width: 250; stroke-linecap: butt; stroke-linejoin: round; fill: none; }
      .center-line { stroke: #ffffff; stroke-width: 10; stroke-linecap: butt; }
      .center-dash { stroke: #ffffff; stroke-width: 8; stroke-dasharray: 40,40; stroke-linecap: butt; }
      .curb-red { stroke: red; stroke-width: 270; stroke-dasharray: 20,20; stroke-linecap: butt; stroke-linejoin: round; fill: none; }
      .curb-white { stroke: white; stroke-width: 270; stroke-linecap: butt; stroke-linejoin: round; fill: none;}
      /* Control-point visualisation (toggle by changing display on #control-visuals) */
      .control-line { stroke: #ffcc00; stroke-width: 2; stroke-dasharray: 6,6; fill: none; }
      .anchor-point { fill: #0077ff; stroke: #ffffff; stroke-width: 1; }
      .control-point { fill: #ff4444; stroke: #ffffff; stroke-width: 1; }
    </style>
  </defs>

  <!-- Background (grass) -->
  <rect x="0" y="0" width="600" height="2000" fill="#76B041" />

<path id="centerpath" d="M300,2000
      S300,1900 300,1800
      S350,1620 400,1550
      S450,1400 450,1300
      S250,1200 180,1100
      S100,800 300,850
      S450,600 450,500
      S150,600 150,450
      S300,200 300,100
      S300,100  300,0" fill="none" />

  <!-- Outer white outline (slightly larger) -->
  <!-- <use href="#centerpath" class="track-outline" /> -->
  <use href="#centerpath" class="curb-white" />
  <use href="#centerpath" class="curb-red" />
  <!-- Road surface -->
  <use href="#centerpath" class="track-surface" />

  <!-- Center dashed line -->
  <use href="#centerpath" class="center-line"/>

  <!-- Control points visualisation for #centerpath (auto-generated by script) -->
  <g id="control-visuals" style="display:inline"></g>

  <script><![CDATA[
    (function() {
      var SVG_NS = 'http://www.w3.org/2000/svg';

      function createEl(tag, attrs) {
        var el = document.createElementNS(SVG_NS, tag);
        for (var k in attrs) {
          if (Object.prototype.hasOwnProperty.call(attrs, k)) {
            el.setAttribute(k, String(attrs[k]));
          }
        }
        return el;
      }

      function parseNumbers(seq) {
        return seq.trim().split(/[\s,]+/).map(function(n){ return parseFloat(n); });
      }

      // Very small parser for M/m, C/c, and S/s commands
      function parsePathD(d) {
        var tokens = [];
        var i = 0;
        // Normalize by ensuring commands are separated
        var norm = d.replace(/([MmCcSsZz])/g, ' $1 ').replace(/\s+/g, ' ').trim();
        var parts = norm.split(' ');
        while (i < parts.length) {
          var cmd = parts[i++];
          var type = cmd.toUpperCase();
          var isRel = cmd !== type;
          if (type === 'M') {
            var nums = [];
            while (i < parts.length && !/[MmCcSsZz]/.test(parts[i])) nums.push(parts[i++]);
            var vals = parseNumbers(nums.join(' '));
            for (var j = 0; j + 1 < vals.length; j += 2) {
              tokens.push({ cmd: 'M', rel: isRel, x: vals[j], y: vals[j+1] });
            }
          } else if (type === 'C') {
            var numsC = [];
            while (i < parts.length && !/[MmCcSsZz]/.test(parts[i])) numsC.push(parts[i++]);
            var v = parseNumbers(numsC.join(' '));
            for (var k = 0; k + 5 < v.length; k += 6) {
              tokens.push({ cmd: 'C', rel: isRel, x1: v[k], y1: v[k+1], x2: v[k+2], y2: v[k+3], x: v[k+4], y: v[k+5] });
            }
          } else if (type === 'S') {
            var numsS = [];
            while (i < parts.length && !/[MmCcSsZz]/.test(parts[i])) numsS.push(parts[i++]);
            var s = parseNumbers(numsS.join(' '));
            for (var m = 0; m + 3 < s.length; m += 4) {
              tokens.push({ cmd: 'S', rel: isRel, x2: s[m], y2: s[m+1], x: s[m+2], y: s[m+3] });
            }
          } else if (type === 'Z') {
            tokens.push({ cmd: 'Z' });
          } else {
            // Unsupported command; stop to avoid misleading visuals
            break;
          }
        }
        return tokens;
      }

      function renderControls() {
        var path = document.getElementById('centerpath');
        var overlay = document.getElementById('control-visuals');
        if (!path || !overlay) return;
        while (overlay.firstChild) overlay.removeChild(overlay.firstChild);

        var d = path.getAttribute('d') || '';
        var tokens = parsePathD(d);
        if (tokens.length === 0) return;

        var curr = null; // current anchor point (absolute)
        var prevWasCurve = false;
        var prevCtrl2 = null; // previous segment's second control point (absolute, for S reflection)
        for (var i = 0; i < tokens.length; i++) {
          var t = tokens[i];
          if (t.cmd === 'M') {
            if (t.rel) {
              var base = curr ? curr : { x: 0, y: 0 };
              curr = { x: base.x + t.x, y: base.y + t.y };
            } else {
              curr = { x: t.x, y: t.y };
            }
            // draw anchor
            overlay.appendChild(createEl('circle', { cx: curr.x, cy: curr.y, r: 10, class: 'anchor-point' }));
            prevWasCurve = false;
            prevCtrl2 = null;
          } else if (t.cmd === 'C' && curr) {
            var cx1 = t.rel ? curr.x + t.x1 : t.x1;
            var cy1 = t.rel ? curr.y + t.y1 : t.y1;
            var cx2 = t.rel ? curr.x + t.x2 : t.x2;
            var cy2 = t.rel ? curr.y + t.y2 : t.y2;
            var ex = t.rel ? curr.x + t.x : t.x;
            var ey = t.rel ? curr.y + t.y : t.y;
            // handle lines
            overlay.appendChild(createEl('line', { x1: curr.x, y1: curr.y, x2: cx1, y2: cy1, class: 'control-line' }));
            overlay.appendChild(createEl('line', { x1: ex, y1: ey, x2: cx2, y2: cy2, class: 'control-line' }));

            // control points
            overlay.appendChild(createEl('circle', { cx: cx1, cy: cy1, r: 10, class: 'control-point' }));
            overlay.appendChild(createEl('circle', { cx: cx2, cy: cy2, r: 10, class: 'control-point' }));

            // end anchor
            overlay.appendChild(createEl('circle', { cx: ex, cy: ey, r: 10, class: 'anchor-point' }));
            curr = { x: ex, y: ey };
            prevWasCurve = true;
            prevCtrl2 = { x: cx2, y: cy2 };
          } else if (t.cmd === 'S' && curr) {
            // compute reflected first control point
            var rx1, ry1;
            if (prevWasCurve && prevCtrl2) {
              rx1 = 2 * curr.x - prevCtrl2.x;
              ry1 = 2 * curr.y - prevCtrl2.y;
            } else {
              rx1 = curr.x;
              ry1 = curr.y;
            }
            var sx2 = t.rel ? curr.x + t.x2 : t.x2;
            var sy2 = t.rel ? curr.y + t.y2 : t.y2;
            var sx = t.rel ? curr.x + t.x : t.x;
            var sy = t.rel ? curr.y + t.y : t.y;

            // handle lines
            overlay.appendChild(createEl('line', { x1: curr.x, y1: curr.y, x2: rx1, y2: ry1, class: 'control-line' }));
            overlay.appendChild(createEl('line', { x1: sx, y1: sy, x2: sx2, y2: sy2, class: 'control-line' }));

            // control points (reflected C1, explicit C2)
            overlay.appendChild(createEl('circle', { cx: rx1, cy: ry1, r: 10, class: 'control-point' }));
            overlay.appendChild(createEl('circle', { cx: sx2, cy: sy2, r: 10, class: 'control-point' }));

            // end anchor
            overlay.appendChild(createEl('circle', { cx: sx, cy: sy, r: 10, class: 'anchor-point' }));
            curr = { x: sx, y: sy };
            prevWasCurve = true;
            prevCtrl2 = { x: sx2, y: sy2 };
          }
        }
      }

      function setupObserver() {
        var path = document.getElementById('centerpath');
        if (!path) return;
        var rafId = 0;
        var mo = new MutationObserver(function(mutations) {
          for (var i = 0; i < mutations.length; i++) {
            if (mutations[i].type === 'attributes' && mutations[i].attributeName === 'd') {
              if (rafId) cancelAnimationFrame(rafId);
              rafId = requestAnimationFrame(renderControls);
              break;
            }
          }
        });
        mo.observe(path, { attributes: true, attributeFilter: ['d'] });
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', function(){ renderControls(); setupObserver(); });
      } else {
        renderControls();
        setupObserver();
      }
    })();
  ]]></script>

  <!-- Start line: solid white band across the track at bottom (approx where path begins) -->
   <g id="start">
    <rect x="300" y="1900" width="250" height="20" rx="2" ry="2" transform="translate(-125,-10)" fill="#ffffff" />
    <text x="300" y="1902" font-family="Arial" font-size="20" text-anchor="middle" dominant-baseline="middle" font-weight="bold">START</text>
  </g>

  <!-- Finish band: chequered rectangle across the track at top -->
  <g id="finish">
    <rect x="300" y="60" width="250" height="40" transform="translate(-125,-20)" fill="url(#checker)" stroke="#000000" stroke-width="1" />
  </g>



  <!-- Light border and printer bleed guide (5mm bleed)
  <rect x="5" y="5" width="590" height="1990" fill="none" stroke="#000000" stroke-dasharray="10,10" stroke-width="1" opacity="0.6" />
  <text x="12" y="22" font-family="Arial" font-size="18">Bleed guide: 5mm (trim to 600x2000mm)</text> -->

</svg>
